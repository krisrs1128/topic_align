---
title: "Simulations"
output:
  pdf_document:
    template: notes/style.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE, message = FALSE, warning = FALSE, fig.width = 5, fig.height = 2)
```

```{r}
library("MASS")
library("MCMCpack")
library("dplyr")
library("embed")
library("ggplot2")
library("ggraph")
library("magrittr")
library("pdist")
library("purrr")
library("stringr")
library("superheat")
library("tidygraph")
library("tidymodels")
library("tidyr")
library("tidytext")
library("topicmodels")
source("R_LSY/align_topics_all_functions.R")
source("simulation_functions.R")
set.seed(1234)
(theme_minimal() + 
  theme(
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "#f7f7f7"),
    panel.border = element_rect(fill = NA, color = "#0c0c0c", size = 0.6),
    legend.position = "bottom"
  )) %>%
  theme_set()
```

```{r}
N <- 1000
K <- 6
V <- 100
sim_data <- equivalence_data(N, V, K, list(beta = .5, gamma = 0.1))
alignment <- vis_wrapper(sim_data$x, ceil(1.5 * K))
```

```{r, fig.height = 5, fig.width = 7}
superheat(log(1 + sim_data$x), pretty.order.rows = TRUE)
```

```{r, fig.height = 3, fig.width = 6}
alignment$p2
```

Compare the true with the estimated betas, before any perturbation.

```{r, fig.height = 5, fig.width = 5}
betas <- as_tibble(sim_data$B) %>%
  mutate(
    estimate = FALSE,
    k_LDA = letters[row_number()],
    i = 1
  ) %>%
  rename_all(~ str_replace(., "V", ""))

umap_res <- merge_betas(betas, alignment$fits$betas, K) %>%
  betas_umap(neighbors = 5)
```

```{r, fig.width = 3, fig.height = 3}
ggplot(umap_res$scores, aes(umap_1, umap_2)) +
  geom_point(aes(shape = estimate)) +
  coord_fixed()
```

Now include the perturbed betas in the plot, and compare with estimates at a
more refined $K$.

```{r}
betas <- map_dfr(
  sim_data$B_tilde, 
  ~ as_tibble(.) %>% 
    set_names(1:ncol(.)) %>%
    mutate(
      estimate = FALSE,
      i = row_number()
    ), 
  .id = "k_LDA"
) %>%
  mutate(k_LDA = letters[as.numeric(k_LDA)])

umap_res <- merge_betas(betas, alignment$fits$betas, K) %>%
  betas_umap(neighbors=10)
```

```{r, fig.width = 4, fig.height = 4}
ggplot(umap_res$scores, aes(umap_1, umap_2)) +
  geom_point(aes(shape = estimate, col = k_LDA), alpha = 0.8) +
  facet_wrap(~ estimate) +
  coord_fixed()
```

```{r, fig.width = 6, fig.height = 3}
K <- 10
N <- rep(25, 6)
V <- 200
sim_data <- environment_shifts(N, K, K, list(pool = 0.2, e = rep(.5, length(N)), beta = 1))

sim_data$gammas %>%
  pivot_longer(-environment, names_to = "k_LDA", values_to = "g") %>%
  ggplot(aes(k_LDA, log(g))) +
  geom_point(alpha = 0.4, size = 0.9, position = position_jitter(w = 0.1)) +
  ylim(-10, 0) +
  facet_wrap(~ environment)
```

```{r}
x_pool <- sim_data$x %>%
  select(-environment) %>%
  mutate(ix = row_number()) %>%
  column_to_rownames("ix")
pooled_fit = LDA(x = x_pool, k = K)
```

```{r}
fits <- sim_data$x %>%
  split(.$environment) %>%
  map(~ LDA(x = select(., -environment), k = 4))
```

The pooled fit.

```{r}
memberships <- tidy(pooled_fit, "gamma") %>%
  left_join(
    sim_data$x %>%
      mutate(document = as.character(row_number())) %>%
      select(document, environment)
  )
hclust_result <- hclust(dist(pooled_fit@gamma))
document_order <- pooled_fit@documents[hclust_result$order]
memberships <- memberships %>%
  mutate(
    document = factor(document, levels = document_order),
    topic = as.factor(topic)
  )
```

```{r, fig.height = 8, fig.width = 5}
ggplot(memberships, aes(gamma, document, fill = topic, col = topic)) +
  geom_col(position = position_stack()) +
  facet_grid(environment ~ ., scales = "free", space = "free") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_color_brewer(palette = "Set3", guide = FALSE) +
  scale_fill_brewer(palette = "Set3") +
  labs(x = "Topic Membership", y = "Sample", fill = "Topic") +
  theme(
    strip.text.y = element_text(size = 8, angle = 0),
    axis.text.y = element_blank(),
  )
```

Instead consider alignment across environments.

```{r}
betas <- map(fits, ~ .@beta)
masses <- map(fits, ~ matrix(colSums(.@gamma), ncol = 1))
alignments <- align_pairs(betas, masses, reg = 2e-2)
```

```{r, fig.height = 4, fig.width = 6}
G <- graph_data(alignments, masses)
ggraph(G, "fr") +
  geom_edge_link(aes(width = weight, alpha = weight)) +
  geom_node_label(aes(label = k, fill = group, size = mass)) +
  scale_edge_width(range = c(0, 3)) +
  scale_fill_brewer(palette = "Set2") +
  guides(fill = guide_legend(override.aes = aes(label = ""))) +
  scale_size(range = c(.1, 5), guide = FALSE)
```

```{r}
fits[[5]]@beta[4, ]
fits[[3]]@beta[4, ]
```
```{r}
betas <- c(map(fits, ~ .@beta), list(log(sim_data$B)))
masses <- c(
  map(fits, ~ matrix(colSums(.@gamma), ncol = 1)),
  list(matrix(colSums(select(sim_data$gammas, -environment)), ncol = 1))
) %>%
  map(~ . / sum(.))

alignments <- align_pairs(betas, masses, reg = 2e-2)
G <- graph_data(alignments, masses)
```

```{r, fig.height = 3, fig.width = 6}
G <- G %>%
  mutate(type = group == "7")

ggraph(G, "bipartite") +
  geom_edge_link(aes(width = weight, alpha = weight)) +
  geom_node_label(aes(label = k, fill = group, size = mass)) +
  scale_edge_width(range = c(0, 3)) +
  scale_fill_brewer(palette = "Set2") +
  guides(fill = guide_legend(override.aes = aes(label = ""))) +
  scale_size(range = c(.1, 5), guide = FALSE)
```
