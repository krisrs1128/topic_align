---
title: "Simulations"
output:
  pdf_document:
    template: notes/style.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache = FALSE, message = FALSE, warning = FALSE, fig.width = 5, fig.height = 2)
```

\begin{enumerate}
\item The purpose of simulation is to provide a controlled environment within
which we can compare alternative analysis strategies. At the very least, we can
define a distance between learned alignments and specify which choices lead to
similar and different alignments. Ideally, we could also say something about
whether one alignment is ``better'' than another, but I'm not worried if we
can't answer this definitively.
\item Strategy 1 [Ordinary LDA]: We could just simulate from an LDA model with a
fixed $K$. This sounds a little silly -- why bother with alignment? -- but the
truth is we'd never know $K$ in practice, so the alignment exercise could still
be productive. This simulation is also useful if we want to illustrate how
refinements (and their associated metrics) look before and after the true $K$ is
hit.
\item Something I don't like about just simulating from a fixed $K$ is that
people might then become fixated on choosing the ``right'' $K$, which is
inimical\footnote{To use a word I just learned.} to the whole point of the
study. I'd like to argue that none of the choices of $K$ are true, but for a
given purpose, there might be a few ranges of $K$ where results are similar.
\end{enumerate}

# Strategy 2: Branching $\beta$'s
\begin{enumerate}
\item For this reason, a more complex setup might be useful. The idea in this
strategy is to simulate topics that branch off from one another over time. We
would simulate documents from the topics at the leaves. However, since we know
the overall branching structure, we can argue that topics with a similar
most-recent-common-ancestor should appear closer to one another in our diagram.
Further, it would be interesting if the intermediate branches on the tree are
somehow recovered when estimating with smaller $K$.
\item How to implement strategy 2, specifically? We can define something
inductively. Start with a $\mu_{0} = 0$. Given a tree of means, we simulate a
new leaf node according to
\begin{align*}
\mu_{i} \vert \mu_{\mathcal{P}\left(i\right)} &\sim \Gsn\left(\mu_{i} \vert \mu_{\mathcal{P}\left(i\right)}, T_{\mathcal{P}\left(i\right)} I_{d}\right)
\end{align*}
where $T_{\mathcal{P}\left(i\right)}$ denotes the time elapsed between the
parent node $\mathcal{P}\left(i\right)$ and all its children.
\item To fully specify this, we need to determine (i) the $T_i$'s and (ii) the
number of children for each node. For (i), we just simulate $T_i \sim
\text{Expo}\left(\lambda\right)$, and for (ii) we just always choose 2. \item
This is a simulation in $\reals^{V}$, but our data have to lie on $\simplex^{V -
1}$. So, let's squash all the means onto the simplex. Specifically, suppose $L$
indexes all the leaf nodes. Then we define topics according to,
\begin{align*}
\beta_{l} := \frac{\exp{\mu_{l}}}{\sum_{l^{\prime} \in L} \exp{\mu_{l^{\prime}}}},
\end{align*}
where $\exp{}$ is applied elementwise.
\end{enumerate}

# What does strategy 2 look like?

```{r}
library("Barycenter")
library("MCMCpack")
library("dplyr")
library("embed")
library("ggplot2")
library("ggraph")
library("ggrepel")
library("igraph")
library("magrittr")
library("purrr")
library("stringr")
library("tidygraph")
library("tidymodels")
library("tidyr")
library("topicmodels")
source("R_LSY/align_topics_all_functions.R")
source("simulation_functions.R")
set.seed(123)
mytheme <- theme_minimal() + 
  theme(
    panel.grid.minor = element_blank(),
    panel.background = element_rect(fill = "#f7f7f7"),
    panel.border = element_rect(fill = NA, color = "#0c0c0c", size = 0.6),
    legend.position = "bottom"
  )
theme_set(mytheme)
```

```{r}
n_lev <- 3
tree <- generate_tree(n_lev)
topics <- tree_topics(tree)
```

```{r, fig.cap = "A simulated tree. Larger jumps in time will lead to larger differences between parent and child topics."}
ggplot(tree %>% mutate(m = as.numeric(m)), aes(x = m, y = time)) +
  geom_segment(aes(xend = m - 1, yend = parent_time), col = "#d3d3d3") +
  geom_point() +
  geom_text_repel(aes(label = node))
```

```{r, fig.cap = "Topics associated with tree nodes, at the three simulated levels (plus root). Notice that neighboring rows tend to have similar b[k,v]'s.", echo = FALSE, fig.height = 3, fig.width = 4}
cbind(tree, topics) %>%
  pivot_longer(cols = c(`1`:`10`), names_to = "v") %>%
  ggplot() +
  geom_tile(aes(x = v, fill = value, y = as.factor(node)), stat = "identity") +
  facet_grid(m ~ ., scale = "free_y", space = "free") +
  labs(x = "word", y = "Tree Node") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_distiller(direction = 1) +
  theme(
    panel.spacing=unit(.05, "lines"),
    panel.border = element_rect(color = "black", fill = NA, size = 1),
    strip.background = element_rect(color = "black", size = 1),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  )
```

# Counts from Branching $\beta$'s

\begin{enumerate}
\item Given these $\beta$'s, we can simulate a dataset of counts $\*X\in
\reals^{n \times V}$. We simulate $\gamma_{i} \sim \text{Dir}\left(\alpha
\*1_{K}\right)$ and then draw $\*x_{i} \sim \text{Mult}\left(n_{0},
B\gamma_{i}\right)$ where $B \in \reals^{V \times K}$ concatenates all the
topics horizontally.
\item A larger $\alpha$ creates $\gamma_{i}$'s across the full polytope whose
corners are $\beta_{k}$. Smaller $\alpha$ encourages $\gamma_{i}$ to concentrate
at corners or edges of this polytope. The choice of $\alpha$ basically
interpolates between gradient and clustering structure. Since it seems easier to
recover hierarchical structure in the more clustered setting, we choose $\alpha
= 0.1$.
\end{enumerate}

```{r}
leaves <- cbind(tree, topics) %>%
  filter(leaf) %>%
  select(-node, -parent, -leaf, -m, -parent_time, -K, -k_LDA, -k_LDA_)
n <- 100
gamma <- rdirichlet(n, alpha = rep(0.1, nrow(leaves)))
colnames(gamma) <- seq(2 ^ n_lev, 2 ^ (n_lev + 1) - 1)
x <- simulate_lda(leaves, gamma)
fits <- run_lda_models(x, 2 ^ seq(0, n_lev), c(.1), "VEM", 123, reset = TRUE)
```

```{r, fig.cap = "Example fitted topics, from the branching scenario.", echo = FALSE, fig.width = 4, fig.height = 3}
fits$betas$k_LDA_ <- as.factor(fits$betas$k_LDA)
ggplot(fits$betas, aes(x = w, y = reorder(k_LDA_, desc(k_LDA_)), fill = b)) +
  geom_tile() +
  facet_grid(m ~ ., scale = "free", space = "free") +
  labs(x = "word", y = "topic") +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_distiller(direction = 1) +
  theme(
    panel.spacing=unit(.05, "lines"),
    panel.border = element_rect(color = "black", fill = NA, size = 1),
    strip.background = element_rect(color = "black", size = 1),
    axis.ticks.y = element_blank()
  )
```
```{r, fig.cap = "Alignment when using estimated topics.", fig.width = 4, fig.height = 2.5}
alignment <- align_topics(fits)
visualize_aligned_topics(alignment)
visualize_aligned_topics(alignment, method = "beta_alignment")
```

# Evaluation Proposal

\begin{enumerate}
\item There are two failure modes for topic alignment: we may fail to recover
reliable topics, and even if we do, we may fail to properly align them across
levels. It is difficult to give formal definitions for either of these. This is
because if we simulate from a true topic model, then there can only be one
"correct" $K$ -- we would be able to evaluate estimation accuracy for that $K$,
but not the others. Since our algorithm is not positing a specific generative
mechanism for how topic hierarchies arise, we cannot appeal to the usual
strategy of (a) simulate from the generative model and (b) verify that
parameters of the generative model can be recovered, given enough signal.
\item The problem of trying to evaluate unsupervised methods without a clearly
specified generative mechanism is not a new one. It arises in evaluation of
clustering and dimensionality reduction algorithms, and a common approach there
is to simulate data with some structure known in advance. Studying the resulting
scores or clusters can be informative. For example, doing this for t-SNE and
UMAP revealed that the density of points and distances between clusters are not
captured by the reductions, and so should not be interpreted in real data
analysis.
\item Example simulation structure that we can evaluate topic alignment include,
\begin{enumerate}
\item Standard topic model at a fixed $K$. There is no real hierarchical
structure in this data, and it would be interesting to see whether the resulting
tree sheds any light on this.
\item A fixed-length topic hierarchy. This is related to the topic tree
structure from the previous section, but with more control of the resulting
tree. Specifically, branching times are all fixed in advance (specified by the
experimenter), and only depend on depth, not which particular descendant subtree
you belong to. Second, to children topics for a given node, we first simulate a
random direction associated with a node. One of the children moves in the
direction for a fixed length, the other moves in the opposite direction for the
same length.
\item Topics lying along a high-dimensional curve. There is neither hierarchical
nor topic structure here. We expect the algorithm to fit a few topics along the
curve, adding more topics intermediate between these as $K$ increases.
\item Completely uniform on simplex. There is no low-dimensional structure here.
This is a relevant reference because we want to make sure we aren't fooled into
reading topic structure in our figures when in fact there is none.
\end{enumerate}
\item Once we run these simulations, we can simply visualize the resulting tree.
However, there is always the question of how things would turn out if we
simulated it again -- illustration data are random, after all. If we just
repeat the experiment many times, then we would have too many trees to be able
to look at all of them at once.
\item To resolve this, we propose embedding edges from all the simulation
replicates. We represent each edge by the topic vectors that they link. We can
reduce the dimensionality of these $2V$-dimensional vectors and visualize them.
If, between simulation runs, there are edges that link similar pairs of topics,
then they should appear close to one another in the embedding. We can visually
encode the weight of these edges by the size of the points. In this way, we can
study variation in both the learned topics and the weights between them.
\item In principle, we could link these embeddings with edges corresponding to
the topic that links them. It's like an inverted version of the tree, each edge
becomes a node and each node becomes an edge.
\item This makes me wonder why not just embed the topics directly and overlay
edges with different weights. I haven't made this plot, but I would be concerned
that there would be too many overlapping edges. I suspect it is harder to
compare edge weights when they are drawn as links spread all over the plot than
when they are drawn as points at a single location.
\end{enumerate}

```{r}
simulate_replicate <- function(beta, gamma, K_max = 8) {
  x <- simulate_leaves(beta, gamma)
  wrapper <- vis_wrapper(x, K_max)
  endpoint_topics(wrapper$fits$beta, wrapper$alignment)
}

beta <- cbind(tree, topics) %>%
  pivot_longer(-node:-k_LDA_, names_to = "w", values_to = "b") %>%
  mutate(
    node_id = node,
    w = as.numeric(str_extract(w, "[0-9]+")),
    depth = as.integer(as.character(m))
  )

edges <- map_dfr(seq_len(5), ~ simulate_replicate(beta, gamma), .id = "replicate")
edge_fits <- embed_edges(edges)
```
 
\begin{enumerate}
\item The figure below\footnote{or above, who knows with Latex} shows an example
embedding with the topic tree from before. Each column is a different depth in
the tree, the two rows are alternative alignment strategies. Each circle is an
edge embedding from one of 50 simulation replicates.
\item The most obvious pattern is that a few, but not all, edges are
consistently estimated across simulation replicates. This is visible in the
difference in transparency between edges. The more transparent edges are linking
topics that are only found in some of the simulation replicates.
\item A second observation is that the edge weights for the topic beta alignment
tree are more nearly sparse than those from the gamma alignment. The circles for
many beta alignment edges are much smaller. This might be an artifact of how the
edges are being normalized in the gamma alignment (I should check).
\end{enumerate}

```{r}
# construct the edge weights for the true underlying tree
G <- graph.tree(2 ^ 4 - 1) %>%
  as_tbl_graph() %>%
  mutate(
    depth = bfs_dist(1),
    m = 2 ^ depth,
    id = bfs_rank(),
    k = c(1, 1:2, 1:4, 1:8)
  )

G_edges <- activate(G, edges) %>%
  as_tibble()

edge_weights <- G_edges %>%
  left_join(as_tibble(G), by = c("from" = "id")) %>%
  left_join(as_tibble(G), by = c("to" = "id")) %>%
  rename(m = m.x, m_next = m.y, k_LDA = k.x, k_LDA_next = k.y) %>%
  select(m, m_next, k_LDA, k_LDA_next, depth.y) %>%
  mutate(norm_weight = 1 / (2 ^ depth.y)) %>%
  mutate(m = as.factor(m), m_next = as.factor(m_next)) %>%
  select(-depth.y)

# construct the joined topics for the true underlying tree
topics_flat <- cbind(tree, topics) %>%
  mutate(k_LDA = c(1, 1:2, 1:4, 1:8)) %>%
  select(K, k_LDA, `1`:`10`) %>%
  pivot_longer(-K:-k_LDA, names_to = "w", values_to = "b")
beta_true <- endpoint_topics_(topics_flat, edge_weights) %>%
  mutate(replicate = 1, method = "truth")

edge_fits2 <- embed_edges(rbind(edges, beta_true))
```

 
```{r, fig.height = 5, fig.width = 10, fig.cap = "We can embed edges according to the topics that they link. Each point is an edge from one of 20 simulation replicates, each with new data generated from the same topic tree. Edges that have similar source and target topics are placed close to one another. The size of each point is the weight of that edge. Points have been slightly jittered."}
edge_scores <- juice(edge_fits2) %>%
  mutate(endpoints = str_c(k_LDA, k_LDA_next, sep = "_")) %>%
  group_by(replicate, K, endpoints)

ggplot(edge_scores, aes(umap_1, umap_2, col = method)) +
  geom_point(
    aes(size = edge_weight), 
    alpha = 0.6
    #position = position_jitter(w = .5, h = .5)
    ) +
  facet_grid(method ~ K) +
  scale_color_brewer(palette = "Set2") +
  scale_size(range = c(0.1, 6)) +
  guides(color = guide_legend(override.aes = list(alpha = 1, size = 2))) +
  coord_fixed()
```

```{r, fig.width = 4, fig.height = 6}
ggplot(edge_scores %>% filter(replicate %in% 1:5), aes(umap_1, umap_2, col = method)) +
  geom_point(
    aes(size = edge_weight), 
    alpha = 0.4
    #position = position_jitter(w = .5, h = .5)
    ) +
  facet_grid(replicate ~ K) +
  scale_color_brewer(palette = "Set2") +
  scale_size(range = c(0.1, 6)) +
  guides(color = guide_legend(override.aes = list(alpha = 1, size = 2))) +
  coord_fixed()
```

```{r}
betas <- k_topics(5, 10)
betas <- topic_curve(10, 3, 10)
x <- uniform_simplex(100, 10)
```

```{r}
betas <- repulsion_tree()
gamma <- rdirichlet(100, alpha = rep(0.1, 8))
x <- simulate_leaves(betas, gamma)
vis_wrapper(x, 8)
```

```{r}
x_star <- uniform_simplex(50)
vis_wrapper(x_star, 8)
```

```{r}
betas <- k_topics(4)
gamma <- rdirichlet(50, alpha = rep(0.1, 4))
x <- simulate_leaves(betas, gamma)
vis_wrapper(x, 6)
```
```{r}
betas <- topic_curve(5, 3)
gamma <- rdirichlet(50, alpha = rep(0.1, 5))
x <- simulate_leaves(betas, gamma)
vis_wrapper(x, 6)
```

```{r}
betas <- repulsion_tree()
#gamma <- rdirichlet(100, alpha = rep(0.1, 8))
#x <- simulate_leaves(betas, gamma)
#vis_wrapper(x, 8)
head(betas)
```


# Multimodal simulation

\begin{enumerate}
\item How can we evaluate alignment of topics learned across modalities?
\item Strategy 1: We can simulate $\gamma$'s across modes so that some
``columns'' are shared between modes while others are unique. The $\beta$'s can
be completely independent, since we don't really care to compare them anyways.
\item To elaborate, choose $K_{X}, K_{Y}$, and $K_{S}$ for the number of topics
that are unique to $X$ and $Y$ and shared ($S$). For the first $K_{S}$, we can
simulate mixed memberships $\gamma_{k}^{X} \equiv \gamma_{k}^{Y}$. For the
remaining $K_{X}$ topics in $X$, we simulate $\gamma_{k}^{X}$ without regard to
$Y$ (and vice versa).
\item How can we tie together the $\gamma_{k}$'s for shared indices? A simple
approach is to use a stick breaking construction. For $k \leq K_{S}$, we
simulate,
\begin{align*}
\gamma_{k} &:= v_{k}\prod_{k^{\prime} < k} \left(1 - v_{k^{\prime}}\right) \\
v_{k} &\sim \text{Beta}\left(1, \alpha\right),
\end{align*}
and we set $\gamma_{k}^{X} = \gamma_{k}^{Y} = \gamma_{k}$. For the remaining
topics within the $X$ modality, we draw from
\begin{align*}
\gamma_{k} &:= v_{k}\prod_{k^{\prime} = 1}^{K_{S}}\left(1 - v_{k^{\prime}}\right)\prod_{k^{x} = K_{S} + 1}^{k - 1}\left(1 - v_{k^{x}}\right) \\
v_{k^{x}} &\sim \text{Beta}\left(1, \alpha\right),
\end{align*}
and similarly for mode $Y$.
\item The interpretation of the process above is that we take a stick and break
off $K_{S}$ parts, whose lengths correspond to the $\gamma_{k}$'s for the shared
topics. We then clone whatever is left of the stick, so there is one stick per
each mode. Those remaining sticks are then broken independently via the same
mechanism.
\item A downside of Strategy 1 is that it doesn't evaluate our ability to search
for ``soft'' matchings between topics across modes. The shared topics in one
mode can be perfectly matched to the shared topics in the other.
\end{enumerate}

```{r}
gammas <- multimodal_gammas(100, c(3, 3),c(3, 3), k_shared = 4, alpha_shared = 3)
map(gammas, head)
```

```{r}
source <- list(pos = gammas[[1]], mass = rep(1, ncol(gammas[[1]])))
target <- list(pos = gammas[[2]], mass = rep(1, ncol(gammas[[2]])))
transport_align_pair(source, target, lambda = 0.01)
```
